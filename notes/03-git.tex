\chapter{Introduction to git}

The scope of this chapter is to explain the basic mechanisms of git. Git is a
complex tool, using it to its full power can take quite some time to learn.
Something crucial may have been missed while attempting to boil it down to
basics. There is a whole internet full of guides out there and you are
encouraged to supplement these ramblings with more verbose tutorials and
articles. Also, please do not hesitate to ask during lectures or breaks; I love
it when people talk git to me.

\section{Installing git}

Start by installing git on your laptop; on Ubuntu you can do this through
\begin{lstlisting}[style=shell]
  sudo apt-get install git
\end{lstlisting}

\section{Setting up a GIT repository}

You can set up a GIT directory in two ways. You either clone a remote repository
or initialize a new, empty one. In either case you end up on a \emph{branch}
called \emph{master} by default.

To clone a remote repository do
\begin{lstlisting}[style=shell]
  git clone <url>
\end{lstlisting}
where \texttt{<url>} is the URL of the repository to clone. E.g.
\begin{lstlisting}[style=shell]
  git clone /some/path/on/my/computer
  git clone https://github.com/TheBB/TMA4280
\end{lstlisting}
To initialize an empty repository, change to the directory you would like to use
and do
\begin{lstlisting}[style=shell]
  git init .
\end{lstlisting}

\section{Layout of a git repository}

A repository has two parts; the repository information and your local working
tree. The first contains information about all the individual commits, commit
messages, and branches (a sequence of commits) that is recorded. This is stored
in a folder called \texttt{.git} in the root of the repository. The second part
is your local copy of the files in the repository.

You can make a \emph{bare} clone of a repository. This is a directory that only
contains the repository information, i.e. only the \emph{.git} folder of a
normal clone, and no local working tree. You do this through
\begin{lstlisting}[style=shell]
  git clone --bare <url>
  git init --bare .
\end{lstlisting}

As far as git is concerned, adding files already existing locally is handled as
a change to the file where everything was changed (see further down). You just
want to add source code, not files generated by the build system or the compiler
such as object files, libraries, executables or scripts.

\section{Keeping track of changes}

You can see what changes you have made to your local working directory through
\begin{lstlisting}[style=shell]
  git diff
\end{lstlisting}
If you just want to see which files, are changed, but not the changes
themselves, you can use
\begin{lstlisting}[style=shell]
  git status
\end{lstlisting}
This is in general quite useful, it can show more things such as which changes
are marked for committing.

To mark some changes for committing, do
\begin{lstlisting}[style=shell]
  git add <file>
\end{lstlisting}
This \emph{stages} the changes, but they have not yet been committed. To commit
all staged changes, use
\begin{lstlisting}[style=shell]
  git commit
\end{lstlisting}
This will open a text editor where you can enter a commit message. You can
control \emph{which} editor by adding a line such as
\begin{lstlisting}[style=shell]
  export EDITOR=<myeditor>
\end{lstlisting}
to your \texttt{\textasciitilde/.bashrc} file if you are using bash.
Alternatively, you can specify the commit message directly.
\begin{lstlisting}[style=shell]
  git commit -m "my message"
\end{lstlisting}
You can quickly commit all changes (even unstaged ones) to all tracked files by
doing
\begin{lstlisting}[style=shell]
  git commit -a
\end{lstlisting}
The two can be combined:
\begin{lstlisting}[style=shell]
  git commit -am "my message"
\end{lstlisting}

\section{Keeping track of commits}
You can see the commit log through
\begin{lstlisting}[style=shell]
  git log
\end{lstlisting}
You can see the log of commits through
\begin{lstlisting}[style=shell]
  git show <commit>
\end{lstlisting}
The commit hash can be found using git log. Alternatively, you have a few
shortcuts. If you omit the revision, the last commit in the branch will be
shown. If you want to show the previous commit, you can use
\begin{lstlisting}[style=shell]
  git show HEAD~1
\end{lstlisting}

\section{Working with remote repositories}
A remote repository is a clone of this repository. Since GIT is a distributed
revision control system, you can clone a clone, and it still contains all the
information the original clone had.

To add a new remote repository, use
\begin{lstlisting}[style=shell]
  git remote add <name> <url>
\end{lstlisting}
where \texttt{<name>} is a name you want to give the remote. If you initialize a
repository through cloning another, the repository you cloned will be registered
as a remote named \emph{origin}. If you started from scratch, there will be no
remotes by default.

To send data between remotes you can \emph{push} or \emph{pull}.

To push changes to a remote, use
\begin{lstlisting}[style=shell]
  git push <remote> <branch>
\end{lstlisting}
If you omit the branch name, all branches will be pushed. If changes you have
done conflict with changes done in the remote GIT, your push will be denied. You
then have to \emph{pull} from the remote before you push. A push will also be
denied if you push to a remote with a local working tree, and you try to push to
the branch currently checked out on the remote.

To pull changes from a remote, use
\begin{lstlisting}[style=shell]
  git pull --rebase <remote> <branch>
\end{lstlisting}
If you omit the branch name, all branches will be pulled. Please do not forget
the rebase, or you can get yourself in trouble. The pull model is more involved
to explain, and deemed outside the scope of this document.

If there are conflicts, git will try to resolve them. If it cannot, you must do
it. To see which files are in conflict you can use \emph{git status}. Where
there were conflicts you will have something that looks like the following:
\begin{lstlisting}
  <<<<<<< HEAD
  line11
  line22
  =======
  line12
  line21
  >>>>>>> 7f8de8cd5f58cd2fa0b2d18f002ce9d9431c0b8c
\end{lstlisting}

The first line is a starting marker. This is followed by lines that are in
conflict, these are from the local repository. After the equal signs follow the
lines in conflict from the remote repository. Finally an ending marker and the
commit hash from the remote. Change it into what you want it to be and save the
file. Remember that there may be multiple blocks in conflict in each file!

Stage the resolved files through \texttt{git add} and continue the rebase by
doing
\begin{lstlisting}
  git rebase --continue
\end{lstlisting}
